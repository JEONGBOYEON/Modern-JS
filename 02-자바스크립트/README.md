# 2강. 자바스크립트
> 📝 정리: 양현화

### 2.2 자바스크립트의 표준화

```jsx
- J Script : 마이크로소프트
- Java Script : 넷스케이프 커뮤니케이션즈
```

- 둘은 완벽하게 호환되지 않는다.
- & 경쟁 과도
- `(문제)` 브라우저에 따라 웹페이지가 정상적으로 동작하지 않는 `크로스 브라우징 이슈`가 발생하기 시작했다.
- —> 표준화된 자바스크립트의 필요성이 대두
- 1997 7’ 표준화된 자바스크립트 초판 완성 ECMAScript 1

### 2.3 자바스크립트 성장의 역사

📝 `keyword` - `무엇이 가능해 졌는지` 📝

- `Ajax`

  ```jsx
  - 서버와 브라우저가 **비동기** 방식으로 데이터를 교환할 수 있는 통신 기능

  - 웹페이지에서 변경할 필요가 없는 부분은 다시 렌더링 하지 않는다.
  - 서버로부터 필요한 데이터만 전송받아 변경해야 하는 부분만 한정적으로
  렌더링하는 방식이 가능해짐.

  - 부드러운 화면 전환 효과
  ```

- `jQuery`
  ```jsx
  - DOM을 더욳 쉽게 제어
  - 크로스브라우징 이슈 어느정도 해결
  ```
- `V8 자바스크립트 엔진`
  ```jsx
  - 빠른 성능
  ```
- `Node.js`

  ```jsx
  - 구글 V8 엔진으로 빌드된 자바스크립트 런타임 환경
  - 브라우저 **이외의 환경**에서도 동작할 수 있도록
  자바스크립트 엔진을 브라우저에서 **독립시킨** 자바스크립트 실행 환경
  - 서버 사이드 애플리케이션 개발에 주로 사용됨
  - 이에 필요한 모듈, 파일 시스템, HTTP 등 빌트인 API 제공

  - Node.js는 다양한 플랫폼에 적용할 수 있다.
  - Server side 애플리케이션 개발에 주로 사용.

  - NodeJS 환경에서 동작하는 애플리케이션은 JS로 개발한다. (프론트앤드 + 백앤드)

  - 비동기 I/O를 지원한다.
  - 단일 스레드 이벤트 루프 기반으로 동작
  -> 요청 처리 성능이 좋다.

  ```

  - 비동기 I/O(입출력) : Node.js는 입출력 작업을 비동기적으로 처리할 수 있는 기능을 제공한다. 입출력작업(파일 읽기/쓰기, 네트워크 요청 등)은 일반적으로 시간이 소요되는 작업이며, 기존의 동기적인 방식으로 처리하면 대기 시간이 발생하여 성능이 저하될 수 있다.
    그러나 Node.js에서 비동기 I/O를 활용하여 입출력 작업을 백그라운드에서 처리하고, 작업이 완료되면 이벤트를 발생시켜 결과를 처리한다.
    이를 통해 작업이 진행되는 동안 다른 작업을 수행할 수 있으며, 대기 시간이 최소화되어 성능이 향상된다.
  - 단일 스레드 : Node.js는 단일 스레드로 동작한다. 이는 CPU 코어를 하나만 사용한다는 의미이다.
    하지만 Node js는 이벤트 루프라는 개념을 통해 비동기적인 작업을 효율적으로 처리한다.
    **이벤트 루프는 이벤트가 발생할 때까지 블로킹하지 않고, 다른 작업을 처리한 뒤 이벤트를 비동기적으로 처리한다.**
    이를 통해 단일 스레드로도 동시에 여러 요청을 처리할 수 있으며, 병렬적인 작업을 효율적으로 처리할 수 있다.

- `SPA 프레임워크`
  ```jsx
  Angular, React, Vue.js, Svelte 등 다양한 SPA 프레임워크/라이브러리
  ```

### 2.4 자바스크립트와 ECMAScript

```jsx
- 핵심 문법을 규정한다.
- 각 브라우저 제조사는 ECMA 사양을 준수하여 브라우저에 내장되는
JS 엔진을 구현한다.
```

### 2.5 자바스크립트의 특징

```jsx
- 웹 브라우저에서 동작하는 유일한 프로그래밍 언어이다.
- 인터프리터 언어

- 명령형, 함수형, 프로토타입 기반, 객체지향 프로그래밍을 지원하는
멀티 패러다임 프로그래밍 언어이다.
```

<aside style="background-color: #9927bf; padding: 2px;">
📝 인터프리터 언어 vs 컴파일러 언어

</aside>

JS는 인터프리터 언어로 구분한다.
| 컴파일러 언어 | 인터프리터 언어 |
| --- | --- |
| 코드가 실행되기 전 단계인 컴파일 타임에 소스코드 전체를 한번에 머신 코드로 변환 후 실행한다. | 코드가 실행되는 단계인 런타임에 문 단위로 한줄씩 중간 코드인 바이트코드로 변환 후 실행한다. |
| 실행파일을 생성한다. | 실행파일을 생성하지 않는다. |
| 컴파일 단계와 실행 단계가 분리되어 있다.
명시적인 컴파일 단계를 거치고, 명시적으로 실행 파일을 실행한다. | 인터프리트 단계와 실행 단계가 분리되어 있지 않다. 인터프리터는 한 줄씩 바이트코드로 변환하고 즉시 실행한다. |
| 실행에 앞서 컴파일은 단 한번 수행된다. | 코드가 실행될 때마다 인터프리트 과정이 반복 수행된다. |
| 컴파일과 실행단계가 분리되어 있으므로 코드 실행 속도가 빠르다. | 인터프리트 단계와 실행단계가 분리되어 있지 않고 반복 수행되므로 코드 실행 속도가 비교적 느리다. |

- 하지만 대부분의 모던 브라우저에서 사용되는 인터프리터는 전통적인 컴파일러 언어 처럼 명시적인 컴파일 단계를 거치치는 않지만,
- 복잡한 과정을 거치며 일부 소스코드를 컴파일하고 실행한다.
- → 인터프리터 언어의 장점인 동적 기능 지원 + 실행속도 느리다는 단점 보완
  - 현재는 컴파일러와 인터프리터의 기술적 구분이 모호해져가는 추세이다.
- 하지만 JS는 런타임에 컴파일되며 실행 파일이 생성되지 않고 인터프리터의 도움 없이 실행할 수 없기 때문에 컴파일러 언어라고 할 수는 없다.
